User.h

#ifndef USER_H
#define USER_H

#include <iostream>
using namespace std;

// Base class
class User {
public:
    // Virtual method (can be overridden)
    virtual void accessLevel() const {
        cout << "Access Level: Basic User" << endl;
    }

    // Virtual destructor (good practice for inheritance)
    virtual ~User() {}
};

#endif

Employee.h

#ifndef EMPLOYEE_H
#define EMPLOYEE_H

#include "User.h"

// Derived class from User
class Employee : public User {
public:
    // Override accessLevel()
    void accessLevel() const override {
        cout << "Access Level: Employee" << endl;
    }
};

#endif

InventoryManager.h

#ifndef INVENTORYMANAGER_H
#define INVENTORYMANAGER_H

#include "Employee.h"

// Derived class from Employee
class InventoryManager : public Employee {
public:
    // Override accessLevel()
    void accessLevel() const override {
        cout << "Access Level: Inventory Manager (Full Access)" << endl;
    }
};

#endif

main.cpp

#include "InventoryManager.h"

int main() {
    // Create an object of InventoryManager
    InventoryManager manager;

    // Demonstrate which version executes
    manager.accessLevel();  // Calls InventoryManager version

    // Optional: use a pointer to show polymorphism
    User* userPtr = &manager;
    userPtr->accessLevel();  // Still calls InventoryManager version (dynamic dispatch)

    return 0;
}
